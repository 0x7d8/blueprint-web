<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      background: #1a1a1a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
    }
    canvas {
      background: #1a1a1a;
      border: 1px solid #333;
    }
  </style>
</head>
<body>
  <canvas id="puzzleCanvas" width="300" height="300"></canvas>
  <script>
    const canvas = document.getElementById('puzzleCanvas');
    const ctx = canvas.getContext('2d');
    const GRID_SIZE = 3;
    const CELL_SIZE = canvas.width / GRID_SIZE;
    
    // Target state (your logo pattern)
    const TARGET = [
      [0, 1, 0],
      [1, 0, 1],
      [0, 1, 1]
    ];

    // Current state of the puzzle
    let currentState = {
      grid: [],
      emptyPos: { x: 1, y: 1 }  // Always start with empty center
    };

    // Animation state
    let isAnimating = false;
    let moveQueue = [];
    let currentMove = null;
    let animationProgress = 0;

    function initializeRandomPuzzle() {
      // Create a shuffled version of the target
      let pieces = [];
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          if (TARGET[i][j] === 1) {
            pieces.push({x: j, y: i});
          }
        }
      }
      
      // Shuffle pieces
      pieces.sort(() => Math.random() - 0.5);
      
      // Create initial grid
      currentState.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
      currentState.emptyPos = { x: 1, y: 1 };  // Keep center empty
      
      // Place pieces
      pieces.forEach(piece => {
        let placed = false;
        while (!placed) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (x === 1 && y === 1) continue;  // Skip center
          if (currentState.grid[y][x] === 0) {
            currentState.grid[y][x] = 1;
            placed = true;
          }
        }
      });
    }

    function drawPuzzle() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw current state
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (currentState.grid[y][x] === 1) {
            let drawX = x * CELL_SIZE;
            let drawY = y * CELL_SIZE;
            
            // Apply animation offset if this is the moving piece
            if (currentMove && x === currentMove.fromX && y === currentMove.fromY) {
              drawX += currentMove.dx * CELL_SIZE * animationProgress;
              drawY += currentMove.dy * CELL_SIZE * animationProgress;
            }
            
            ctx.fillStyle = '#000';
            ctx.fillRect(
              drawX + 2,
              drawY + 2,
              CELL_SIZE - 4,
              CELL_SIZE - 4
            );
          }
        }
      }
    }

    function findNextMove() {
      const possibleMoves = [
        { dx: -1, dy: 0 },
        { dx: 1, dy: 0 },
        { dx: 0, dy: -1 },
        { dx: 0, dy: 1 }
      ].filter(move => {
        const newX = currentState.emptyPos.x + move.dx;
        const newY = currentState.emptyPos.y + move.dy;
        return newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE;
      });

      // Find a move that gets us closer to the target
      for (const move of possibleMoves) {
        const newX = currentState.emptyPos.x + move.dx;
        const newY = currentState.emptyPos.y + move.dy;
        
        if (TARGET[newY][newX] === 0 && currentState.grid[newY][newX] === 1) {
          return {
            fromX: newX,
            fromY: newY,
            dx: -move.dx,
            dy: -move.dy
          };
        }
      }
      
      return null;
    }

    function animate(timestamp) {
      if (!isAnimating) return;

      if (!currentMove) {
        currentMove = findNextMove();
        if (!currentMove) {
          isAnimating = false;
          setTimeout(startPuzzle, 2000);  // Reset after completion
          return;
        }
        animationProgress = 0;
      }

      // Update animation
      animationProgress += 0.1;
      
      if (animationProgress >= 1) {
        // Complete the move
        const newX = currentMove.fromX + currentMove.dx;
        const newY = currentMove.fromY + currentMove.dy;
        
        currentState.grid[newY][newX] = currentState.grid[currentMove.fromY][currentMove.fromX];
        currentState.grid[currentMove.fromY][currentMove.fromX] = 0;
        currentState.emptyPos = { x: currentMove.fromX, y: currentMove.fromY };
        
        currentMove = null;
        animationProgress = 0;
      }

      drawPuzzle();
      requestAnimationFrame(animate);
    }

    function startPuzzle() {
      initializeRandomPuzzle();
      isAnimating = true;
      currentMove = null;
      animationProgress = 0;
      requestAnimationFrame(animate);
    }

    // Start the puzzle
    startPuzzle();
  </script>
</body>
</html>